# ギャップ分析: Clean Architecture リファクタリング

## 1. 現状調査

### 1.1 既存コードベースの構造

#### ディレクトリレイアウト
```
Portal.C/
├── app/                    # Next.js 15 App Router ページ
│   ├── admin/             # 管理画面
│   ├── events/            # イベント一覧ページ
│   ├── members/           # メンバー一覧ページ
│   ├── profile/           # プロフィール編集ページ
│   ├── timetable/         # 時間割ページ
│   ├── layout.tsx         # ルートレイアウト
│   ├── page.tsx           # ホームページ
│   └── api/auth/          # NextAuth APIルート
├── components/            # UIコンポーネント
│   ├── layout/Navigation.tsx
│   └── MatterHero.tsx
├── lib/                   # ユーティリティとクライアント
│   ├── auth.ts            # 認証ヘルパー
│   ├── auth-options.ts    # NextAuth設定
│   ├── utils.ts           # 汎用ユーティリティ
│   └── supabase/          # Supabaseクライアント
│       ├── client.ts      # ブラウザクライアント
│       ├── server.ts      # サーバークライアント
│       ├── admin.ts       # 管理者クライアント
│       └── middleware.ts  # ミドルウェア
├── types/                 # 型定義
│   ├── database.types.ts  # Supabase自動生成型
│   └── index.ts           # アプリケーション型定義 + ビジネスロジック
└── supabase/migrations/   # データベーススキーマ
    ├── 20241216000001_create_members_table.sql
    ├── 20241216000002_create_tags_table.sql
    ├── 20241216000003_create_events_table.sql
    └── 20241216000004_create_timetables_table.sql
```

#### 再利用可能な資産

**1. データベーススキーマ（完全構築済み）**
- **membersテーブル**: ZITADEL ID統合、学年自動計算関数、RLS（Row Level Security）設定済み
- **tagsテーブル**: スキル・興味タグ管理
- **eventsテーブル**: イベント情報、参加者管理
- **timetablesテーブル**: メンバーの時間割情報

**2. 認証基盤（設定完了）**
- ZITADEL OIDC統合（lib/auth-options.ts）
- NextAuth.js設定
- ロールベースアクセス制御（admin ロール対応）
- セッション管理

**3. Supabaseクライアント（4種類）**
- ブラウザクライアント（lib/supabase/client.ts）
- サーバークライアント（lib/supabase/server.ts）
- 管理者クライアント（lib/supabase/admin.ts）
- ミドルウェアクライアント（lib/supabase/middleware.ts）

**4. 型定義システム**
- Supabase自動生成型（types/database.types.ts）
- アプリケーション型（types/index.ts）: Member, Event, Timetable, Participation

**5. UIコンポーネント**
- Spindle UI統合（@openameba/spindle-ui）
- Tailwind CSS設定
- レイアウトコンポーネント（Navigation）
- ページコンポーネント（会員、イベント、時間割、管理画面）

#### アーキテクチャパターンと制約

**現在のパターン**
- **標準的なNext.js構造**: app/ディレクトリによるファイルベースルーティング
- **直接的なデータアクセス**: UIコンポーネントから直接Supabaseクライアントを呼び出す想定（現在はモックデータ）
- **型定義とビジネスロジックの混在**: types/index.tsに`calculateGrade()`, `isStatusValid()`などのビジネスロジックが含まれる
- **レイヤー分離なし**: プレゼンテーション、ビジネスロジック、データアクセスが明確に分離されていない

**技術的制約**
- Next.js 15 App Routerの使用が必須
- Supabaseをデータベースとして使用
- ZITADELを認証基盤として使用
- TypeScript strict mode有効

**命名規則**
- コンポーネント: PascalCase（Navigation.tsx, MatterHero.tsx）
- ユーティリティ: camelCase（utils.ts, auth.ts）
- 型定義: PascalCase（Member, Event）

**インポートパターン**
- 絶対パスインポート: `@/`エイリアス使用
- 例: `import type { Member } from "@/types"`

### 1.2 統合ポイント

**データモデル/スキーマ**
- PostgreSQL（Supabase）スキーマ完全定義
- 学年自動計算はデータベース関数で実装済み
- Row Level Security（RLS）設定済み
- TypeScript型は自動生成可能

**認証メカニズム**
- ZITADEL OIDC provider
- NextAuth.jsによるセッション管理
- JWT内にロール情報を含む
- RLSとの統合（auth.jwt()）

**外部API/サービス**
- Supabase API（データベース、認証、ストレージ）
- ZITADEL（認証プロバイダー）

## 2. 要件実現可能性分析

### 2.1 技術的ニーズ（EARS要件からの抽出）

#### データモデル
- ✅ **Memberエンティティ**: データベーススキーマ、型定義完備
- ✅ **Eventエンティティ**: データベーススキーマ、型定義完備
- ✅ **Timetableエンティティ**: データベーススキーマ、型定義完備
- ✅ **値オブジェクト候補**: Email, StudentId, EventCapacity（実装は未）

#### API/サービス
- ✅ **Supabaseクライアント**: 4種類のクライアント実装済み
- ✅ **認証サービス**: ZITADEL統合完了
- ❌ **リポジトリインターフェース**: 未実装
- ❌ **ユースケース**: 未実装

#### UI/コンポーネント
- ✅ **ページコンポーネント**: 全ページ実装済み（モックデータ使用）
- ✅ **UIライブラリ**: Spindle UI導入済み
- ⚠️ **データバインディング**: 現在はモックデータ、実データ統合が必要

#### ビジネスルール/バリデーション
- ⚠️ **学年計算**: データベース関数とTypeScript関数に重複実装
- ⚠️ **ステータス有効性チェック**: TypeScript関数のみ（types/index.ts）
- ❌ **値オブジェクトバリデーション**: 未実装
- ❌ **ドメインルール**: エンティティ内にカプセル化されていない

#### 非機能要件

**セキュリティ**
- ✅ Row Level Security設定済み
- ✅ ロールベースアクセス制御
- ⚠️ 入力バリデーション: フロントエンドのみ、サーバーサイド強化が必要

**パフォーマンス**
- ✅ データベースインデックス設定済み
- ❌ クエリ最適化: リポジトリパターンで実装予定
- ❌ キャッシング: 未実装

**スケーラビリティ**
- ✅ Supabase（PostgreSQL）でスケーラブル
- ✅ Vercelホスティングでスケーラブル

**信頼性**
- ⚠️ トランザクション境界: ユースケース層で定義予定
- ❌ エラーハンドリング: 統一されたエラー処理が必要

### 2.2 ギャップと制約の特定

#### 欠落機能

**1. ドメイン層（完全欠如）**
- エンティティクラス/インターフェース
- 値オブジェクト
- ドメインサービス
- ビジネスルールのカプセル化

**2. アプリケーション層（完全欠如）**
- ユースケース実装
- ポートインターフェース（リポジトリ、サービス）
- DTO（データ転送オブジェクト）
- アプリケーションサービス

**3. インフラストラクチャ層（部分的実装）**
- ✅ Supabaseクライアント存在
- ❌ リポジトリ実装
- ❌ データマッパー（DB型 ↔ ドメインエンティティ変換）
- ❌ 依存性注入メカニズム

**4. プレゼンテーション層（部分的実装）**
- ✅ ページコンポーネント存在
- ❌ ユースケース統合
- ❌ Server Actions（Next.js 15推奨パターン）
- ❌ 統一されたエラー表示

**5. テスト基盤（未実装）**
- ユニットテストフレームワーク
- インテグレーションテスト
- モック/スタブ実装

#### 調査が必要な項目

**1. 依存性注入（DI）の実装方法**
- **選択肢**:
  - ファクトリー関数パターン（軽量）
  - DIコンテナライブラリ（TSyringe, InversifyJS）
  - Next.js App Routerネイティブパターン
- **調査ポイント**: Next.js 15 Server Componentsとの相性、パフォーマンス影響

**2. トランザクション処理**
- **調査ポイント**: Supabaseでのトランザクション実装方法、ユースケース境界での実装パターン

**3. Server ComponentsとClient Componentsのデータ転送**
- **調査ポイント**: DTOのシリアライゼーション、Date型の扱い、エラー伝播

**4. エンティティ実装方式**
- **選択肢**:
  - クラスベース（メソッド含む）
  - インターフェース + 純粋関数
- **調査ポイント**: TypeScriptでの推奨パターン、テスタビリティ

**5. リポジトリインターフェースの粒度**
- **調査ポイント**: 汎用リポジトリ vs 専用リポジトリ、Supabaseクエリビルダーとの統合

#### 既存アーキテクチャからの制約

**1. Next.js App Routerの制約**
- ファイルベースルーティング（app/ディレクトリ）必須
- Server ComponentsとClient Componentsの分離
- Server Actionsの使用推奨

**2. Supabaseの制約**
- PostgreSQL専用（NoSQL非対応）
- RLSによるアクセス制御
- リアルタイムサブスクリプション機能

**3. ZITADEL統合**
- OIDC標準準拠
- JWT内にロール情報を格納
- NextAuth.jsとの統合

### 2.3 複雑性の指標

#### 機能タイプ
- **ドメインロジック**: 中程度（学年計算、ステータス有効性チェック、イベント参加管理）
- **データアクセス**: 標準的CRUD + RLS統合
- **外部統合**: 認証（ZITADEL）、データベース（Supabase）
- **ワークフロー**: シンプル（メンバー登録、イベント参加、プロフィール更新）

#### アーキテクチャの複雑性
- **レイヤー数**: 4層（Domain, Application, Infrastructure, Presentation）
- **抽象化レベル**: 高（ポート/アダプター、依存性逆転）
- **新規パターン**: リポジトリパターン、ユースケースパターン、依存性注入

## 3. 実装アプローチオプション

### Option A: 既存コンポーネントの拡張

**該当しない理由**: Clean Architectureへのリファクタリングは、既存の構造を根本的に変更する必要があり、単なる拡張では実現不可能。

**評価**: ❌ 適用不可

---

### Option B: 新規コンポーネント作成

**アプローチ**: 既存コードを保持したまま、完全に新しいレイヤー構造（src/domain/, src/application/, src/infrastructure/）を作成し、段階的に機能を移行。

#### 新規作成の根拠
- Clean Architectureは既存の構造と根本的に異なる
- レイヤー分離の原則に従うには、新しいディレクトリ構造が必須
- 既存コードとの並行運用により、段階的移行が可能

#### 統合ポイント
- **app/ディレクトリ**: プレゼンテーション層として保持、新しいユースケースを呼び出す
- **lib/supabase/**: 新しいリポジトリ実装のアダプターとして使用
- **types/**: ドメインエンティティ定義に段階的に移行

#### 責任境界
- **src/domain/**: ビジネスルール、エンティティ、値オブジェクト（外部依存なし）
- **src/application/**: ユースケース、ポートインターフェース、DTO
- **src/infrastructure/**: リポジトリ実装、Supabase統合、ZITADEL統合
- **app/ + components/**: プレゼンテーション層（ユースケースを呼び出す）

#### トレードオフ
- ✅ クリーンな分離、テストしやすい
- ✅ 段階的移行が可能
- ✅ 既存機能を壊さない
- ❌ ディレクトリ数増加、初期学習コスト
- ❌ 並行期間中のコード重複

**評価**: ✅ 推奨される基本アプローチ

---

### Option C: ハイブリッドアプローチ（推奨）

**アプローチ**: Option Bをベースに、既存の安定した資産（Supabaseクライアント、ZITADEL設定、UIコンポーネント）を活用しながら、段階的に新しいレイヤーを導入。

#### 組み合わせ戦略

**段階1: 基盤整備（Week 1）**
- 新しいディレクトリ構造作成（src/domain/, src/application/, src/infrastructure/）
- tsconfig.jsonパスエイリアス設定
- 依存性注入メカニズム選定・実装

**段階2: ドメイン層（Week 1-2）**
- エンティティ実装（Member, Event, Timetable）
- 値オブジェクト実装（Email, StudentId, EventCapacity）
- ドメインサービス（必要に応じて）
- **既存資産活用**: types/index.tsのビジネスロジックを移行

**段階3: アプリケーション層（Week 2）**
- ポートインターフェース定義（IMemberRepository, IEventRepository等）
- DTO定義
- 基本ユースケース実装（1-2個のパイロットユースケース）

**段階4: インフラストラクチャ層（Week 2-3）**
- リポジトリ実装（SupabaseMemberRepository等）
- データマッパー（DB型 ↔ ドメインエンティティ変換）
- **既存資産活用**: lib/supabase/クライアントをアダプターとして使用

**段階5: プレゼンテーション層統合（Week 3）**
- パイロットページ（例: メンバー一覧）をユースケース統合
- Server Actions実装
- エラーハンドリング統合
- **既存資産活用**: 既存のUIコンポーネントとSpindle UI

**段階6: 全機能移行（Week 3-4）**
- 残りの機能（イベント、時間割、管理画面）を移行
- モックデータを実データに置き換え
- **既存資産活用**: 既存のページ構造とルーティング

**段階7: テストとドキュメント（Week 4）**
- ユニットテスト実装
- インテグレーションテスト
- アーキテクチャドキュメント作成
- 開発者オンボーディングガイド

#### 段階的実装の詳細

**パイロット機能選定**: メンバー一覧ページ
- シンプルなCRUD操作
- 既存のUIコンポーネント活用可能
- 学習曲線が緩やか

**移行戦略**:
1. 新しいレイヤーでメンバー一覧機能を完全実装
2. 既存のapp/members/page.tsxをリファクタリング
3. 動作確認・フィードバック収集
4. 他の機能に適用

#### リスク軽減策

**技術的リスク**:
- **DI実装の複雑性**: パイロット機能で検証後、パターン確立
- **Server Components統合**: Next.js 15公式ドキュメント参照、コミュニティパターン調査
- **トランザクション処理**: Supabaseドキュメント参照、段階2で調査完了

**プロジェクトリスク**:
- **段階的移行**: 各段階で動作確認、必要に応じてロールバック可能
- **並行開発**: 既存コードを破壊しない、新機能追加は新レイヤーで実装
- **知識共有**: 段階ごとにドキュメント更新、チームレビュー実施

#### トレードオフ
- ✅ バランスの取れたアプローチ
- ✅ 既存資産を最大限活用
- ✅ リスク分散（段階的移行）
- ✅ 各段階でフィードバック可能
- ❌ 計画の複雑性
- ❌ 段階間の調整が必要

**評価**: ⭐ **強く推奨** - 最もバランスが取れた実装アプローチ

## 4. 実装の複雑性とリスク

### 工数見積もり

**工数**: **XL (3-4週間、約26-41日)**

#### 内訳
- **基盤整備**: 2-3日（ディレクトリ構造、DI、設定）
- **ドメイン層**: 5-7日（エンティティ、値オブジェクト、サービス）
- **アプリケーション層**: 4-5日（ユースケース、ポート、DTO）
- **インフラストラクチャ層**: 5-7日（リポジトリ、データマッパー、統合）
- **プレゼンテーション層**: 4-5日（Server Actions、統合、エラーハンドリング）
- **全機能移行**: 3-5日（残機能の移行、モックデータ置き換え）
- **テストとドキュメント**: 3-5日（ユニット/統合テスト、ドキュメント）
- **バッファ**: 2-4日（予期しない問題対応）

**合計**: 26-41日（1人、フルタイム換算）

### リスク評価

**リスク**: **Medium**

#### リスク要因

**技術的未知数（Medium リスク）**:
- Next.js 15 App Routerでの依存性注入パターン
- Supabaseトランザクション処理
- Server ComponentsとClient Componentsのデータ転送

**軽減策**:
- 段階1で技術調査とパイロット実装
- Next.js 15公式ドキュメントとコミュニティベストプラクティス参照
- Supabaseドキュメントとサンプルコード調査

**アーキテクチャ変更の影響（Medium リスク）**:
- 既存コードとの共存期間
- チームの学習曲線
- パターンの一貫性

**軽減策**:
- 段階的移行により影響を最小化
- 各段階でコードレビューとペアプログラミング
- アーキテクチャドキュメントとガイドライン作成

**データ統合（Low リスク）**:
- データベーススキーマ完全構築済み
- Supabaseクライアント動作確認済み

**軽減策**:
- 既存のデータベーススキーマとクライアントを活用
- データマッパーで型安全性を確保

**パフォーマンス（Low リスク）**:
- レイヤー追加によるオーバーヘッド
- 不適切なクエリパターン

**軽減策**:
- リポジトリパターンでクエリ最適化
- 必要に応じてキャッシング導入
- パフォーマンステスト実施

### 成功のための鍵

1. **段階的アプローチ**: 各段階で動作確認とフィードバック
2. **既存資産活用**: データベーススキーマ、認証、UIコンポーネント
3. **明確なドキュメント**: アーキテクチャガイド、コーディング規約
4. **継続的レビュー**: コードレビュー、ペアプログラミング
5. **テスト駆動**: ドメイン層とアプリケーション層のユニットテスト

## 5. 要件-資産マッピング

### Requirement 1: ディレクトリ構造とレイヤー分離

| 受入基準 | 既存資産 | ギャップ | タグ |
|---------|---------|---------|------|
| src/ディレクトリ作成 | なし | 新規作成が必要 | Missing |
| domain/, application/, infrastructure/, presentation/作成 | なし | 新規作成が必要 | Missing |
| app/ディレクトリ保持 | ✅ 既存 | プレゼンテーション層として再定義 | Refactor |
| components/ディレクトリ保持 | ✅ 既存 | プレゼンテーション層として再定義 | Refactor |
| lib/, types/から移行 | ✅ 既存 | 適切なレイヤーへ移行が必要 | Refactor |
| tsconfig.jsonパスエイリアス | ⚠️ 部分的（@/のみ） | レイヤー別エイリアス追加 | Extend |

**推奨アプローチ**: Option C - 新規ディレクトリ作成 + 既存ディレクトリ活用

---

### Requirement 2: ドメインレイヤーの設計

| 受入基準 | 既存資産 | ギャップ | タグ |
|---------|---------|---------|------|
| エンティティ定義（Member, Event, Timetable） | ⚠️ types/index.ts（型定義のみ） | クラス/インターフェース実装が必要 | Missing |
| 外部依存なしの実装 | ❌ 現在ビジネスロジック混在 | 純粋なドメインロジックに分離 | Missing |
| 値オブジェクト（Email, StudentId等） | ❌ なし | 新規実装が必要 | Missing |
| イミュータビリティとバリデーション | ❌ なし | 値オブジェクトに実装 | Missing |
| ドメインサービス | ❌ なし | 必要に応じて実装 | Missing |
| レイヤー依存ルール | ❌ 現在制約なし | TypeScript設定で強制 | Missing |
| ビジネスルールバリデーション | ⚠️ calculateGrade, isStatusValid存在 | エンティティ内にカプセル化 | Refactor |

**推奨アプローチ**: Option B - 新規作成（既存のビジネスロジックを移行）

---

### Requirement 3: アプリケーションレイヤーの設計

| 受入基準 | 既存資産 | ギャップ | タグ |
|---------|---------|---------|------|
| ユースケースクラス | ❌ なし | 新規実装が必要 | Missing |
| 単一責務とexecute()メソッド | ❌ なし | パターン確立が必要 | Missing |
| ポートインターフェース | ❌ なし | 新規定義が必要 | Missing |
| DTO定義 | ❌ なし | 新規定義が必要 | Missing |
| ドメイン層のみに依存 | ❌ 現在制約なし | レイヤールール強制 | Missing |
| 依存性逆転の原則 | ❌ なし | DI実装が必要 | Unknown |
| エラーハンドリング | ⚠️ 部分的 | 統一されたエラー型が必要 | Missing |
| トランザクション境界 | ❌ なし | 実装パターン調査が必要 | Unknown |

**推奨アプローチ**: Option B - 新規作成（調査項目あり）

**調査項目**:
- Next.js 15での依存性注入パターン
- Supabaseトランザクション処理方法

---

### Requirement 4: インフラストラクチャレイヤーの設計

| 受入基準 | 既存資産 | ギャップ | タグ |
|---------|---------|---------|------|
| リポジトリ実装 | ❌ なし | 新規実装が必要 | Missing |
| ポートインターフェース実装 | ❌ なし | アプリケーション層定義後に実装 | Missing |
| Supabaseクライアント設定 | ✅ lib/supabase/（4種類） | アダプターとして活用 | Extend |
| ZITADEL認証プロバイダー | ✅ lib/auth-options.ts | アダプターとして活用 | Extend |
| DB型↔ドメインエンティティ変換 | ❌ なし | データマッパー実装が必要 | Missing |
| エラー変換 | ⚠️ 部分的 | 標準化されたエラー型に変換 | Missing |
| 外部API統合 | ⚠️ 必要に応じて | 現時点では不要 | N/A |
| 依存性注入 | ❌ なし | DI実装が必要 | Unknown |

**推奨アプローチ**: Option C - 既存Supabaseクライアント活用 + 新規リポジトリ実装

---

### Requirement 5: プレゼンテーションレイヤーの設計

| 受入基準 | 既存資産 | ギャップ | タグ |
|---------|---------|---------|------|
| app/ディレクトリ保持 | ✅ 既存 | ユースケース統合が必要 | Refactor |
| components/ディレクトリ保持 | ✅ 既存 | UIロジックのみに制限 | Refactor |
| サーバーコンポーネント | ⚠️ 一部実装 | ユースケース呼び出しに変更 | Refactor |
| クライアントコンポーネント | ⚠️ 一部実装 | インタラクティブUIのみに制限 | Refactor |
| ユースケース/DTO通信 | ❌ 現在直接データアクセス | 統合が必要 | Missing |
| データベース/認証直接呼び出し禁止 | ❌ 現在想定 | パターン変更が必要 | Constraint |
| Server Actions | ❌ なし | Next.js 15推奨パターン実装 | Missing |
| エラー表示 | ⚠️ 部分的 | 統一されたエラーUI | Missing |

**推奨アプローチ**: Option C - 既存ページ/コンポーネント活用 + ユースケース統合

---

### Requirement 6: 依存性ルールの遵守

| 受入基準 | 既存資産 | ギャップ | タグ |
|---------|---------|---------|------|
| ドメイン層独立性 | ❌ 現在制約なし | レイヤー分離が必要 | Missing |
| アプリケーション層依存ルール | ❌ 現在制約なし | レイヤー分離が必要 | Missing |
| インフラストラクチャ層依存ルール | ❌ 現在制約なし | レイヤー分離が必要 | Missing |
| プレゼンテーション層依存ルール | ❌ 現在制約なし | レイヤー分離が必要 | Missing |
| 依存性逆転の原則 | ❌ なし | ポート/アダプターパターン実装 | Missing |
| TypeScript/リンター設定 | ⚠️ 基本設定のみ | レイヤー依存ルール強制設定 | Missing |
| ビルド/リント時エラー検出 | ❌ なし | 設定強化が必要 | Missing |

**推奨アプローチ**: Option B - 新規実装（TypeScript設定とリンター強化）

---

### Requirement 7: 既存機能の保持

| 受入基準 | 既存資産 | ギャップ | タグ |
|---------|---------|---------|------|
| メンバー管理機能 | ✅ UI実装済み（モック） | 実データ統合が必要 | Refactor |
| イベント管理機能 | ✅ UI実装済み（モック） | 実データ統合が必要 | Refactor |
| タイムテーブル機能 | ✅ UI実装済み（モック） | 実データ統合が必要 | Refactor |
| 認証機能 | ✅ ZITADEL統合完了 | 新レイヤーとの統合 | Extend |
| 管理者機能 | ✅ UI実装済み | 実データ統合が必要 | Refactor |
| データベーススキーマ | ✅ 完全構築済み | そのまま使用 | ✓ Ready |
| 回帰テスト | ❌ なし | テスト実装が必要 | Missing |

**推奨アプローチ**: Option C - 既存UI活用 + 新レイヤー統合

---

### Requirement 8-10（テスタビリティ、マイグレーション、ドキュメント）

| 要件エリア | 既存資産 | ギャップ | タグ |
|---------|---------|---------|------|
| テストフレームワーク | ❌ なし | Jest/Vitest導入が必要 | Missing |
| ユニットテスト | ❌ なし | ドメイン/アプリケーション層実装 | Missing |
| 統合テスト | ❌ なし | リポジトリ/ユースケーステスト実装 | Missing |
| マイグレーション計画 | ❌ なし | 7段階計画作成済み | ✓ Planned |
| アーキテクチャドキュメント | ❌ なし | 作成が必要 | Missing |
| 開発者ガイド | ❌ なし | 作成が必要 | Missing |
| コード生成テンプレート | ❌ なし | 作成推奨 | Missing |

**推奨アプローチ**: Option B - 新規作成（段階7で実装）

## 6. まとめ

### 現状とギャップの要約

Portal.Cは、**データベーススキーマと認証システムが完全に構築されている**ものの、**アーキテクチャ層の分離が存在しない**標準的なNext.jsアプリケーションです。Clean Architectureへのリファクタリングには、以下の主要ギャップが存在します:

- **ドメイン層**: 完全欠如（エンティティ、値オブジェクト、サービス）
- **アプリケーション層**: 完全欠如（ユースケース、ポート、DTO）
- **インフラストラクチャ層**: 部分的実装（クライアント存在、リポジトリなし）
- **プレゼンテーション層**: 部分的実装（UI存在、統合なし）
- **テスト基盤**: 未実装

一方で、以下の**技術的資産**が活用可能:
- ✅ Supabaseデータベーススキーマ完全構築
- ✅ ZITADEL認証統合完了
- ✅ 型定義システム整備済み
- ✅ UIコンポーネント実装済み

### 推奨アプローチ

**Option C: ハイブリッドアプローチ**（段階的移行）を強く推奨します。

**理由**:
1. 既存の安定した資産（データベース、認証、UI）を最大限活用
2. 段階的移行によりリスクを最小化
3. 各段階で動作確認とフィードバックが可能
4. チームの学習曲線を緩やか化

**7段階の移行計画**:
1. 基盤整備（ディレクトリ、DI、設定）
2. ドメイン層（エンティティ、値オブジェクト）
3. アプリケーション層（ユースケース、ポート、DTO）
4. インフラストラクチャ層（リポジトリ、データマッパー）
5. プレゼンテーション層統合（パイロット機能）
6. 全機能移行（残機能の移行）
7. テストとドキュメント

### 工数とリスク

- **工数**: XL (3-4週間、約26-41日)
- **リスク**: Medium（技術的未知数はあるが軽減策明確）

### デザインフェーズでの優先調査項目

1. **依存性注入**: Next.js 15での実装パターン（ファクトリー vs DIコンテナ）
2. **トランザクション処理**: Supabaseでの実装方法
3. **データ転送**: Server Components ↔ Client Componentsのベストプラクティス
4. **エンティティ実装**: クラスベース vs インターフェース+関数
5. **リポジトリ粒度**: 汎用 vs 専用リポジトリパターン

### 成功のための鍵

1. **段階的アプローチ**: 各段階で検証とフィードバック
2. **既存資産活用**: データベース、認証、UIを最大限利用
3. **明確なドキュメント**: アーキテクチャガイド、規約
4. **継続的レビュー**: コードレビュー、ペアプログラミング
5. **テスト駆動**: ドメイン層・アプリケーション層のユニットテスト

---

**次のステップ**: `/kiro:spec-design clean-architecture-refactor` を実行して、技術設計ドキュメントを生成してください。
